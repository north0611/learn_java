1.构造方法：创建实例的时候初始化实例内的字段（相当于new instances + setFiled）。
	形如，函数为类名，没有返回值（也没有void），通过new来调用。demo_1
	无显示声明构造方法时，编译器会默认创建构造public无参的构造方法，有任意个参数的显示声明时则不会。demo_2
	无显示构造方法，或未在构造函数中初始化字段时，引用字段默认为null，数值为0，布尔为false。demo_3
	字段初始化顺序：（1）声明处显示赋值 => (2)构造函数中赋值。demo_3
	构造函数可以通过参数形式和个数，实现多态；一个构造函数可以调用其他构造this(...)，便于代码复用。demo_4
2.方法重载：通过参数的不同类型或者个数实现（返回值类型原则上应该相同），以实现一个名字多个功能的目的。
	参数相同，返回值类型不同,也會報錯。demo_1
3.继承：继承首先可以复用代码，extends实现继承，超类，父类，基类=>子类，扩展类。
	缺省继承=>没有指定父类的类，编译器会自动追加extends Object，所以，除了Object，都有父类。Father
	父类成员=>想要继承父类的成员变量和方法，可以使用protected替代private关键字。
			子类使用父类字段方法时，可以使用super.field。Son1
	父类构造=>编译器会自动在子类的构造函数第一行，生成super();如果父类没有显示Father()方法，则会报错。
			解决方法是手动在子类的构造函数中追加father中存在的构造函数，必须在最前。Son1
	向上转型=>子类强转为父类，相当于将子类转换为更抽象的父类（教师->人）,安全。Son2
	向下转型=>父类强转为子类，子类如果有多于父类的成员，则会报错，抛出ClassCastException。Son3
			可以使用clazz instance of Class 判断，成功会再强转。Son2
	继承特点=>单继承，不能有两个父类。所有类的最终根类都是Object。Son4
	
